/*--TABLO OLUSTURMA--
CREATE TABLE student
(id CHAR(4),
name VARCHAR(20),
age NUMBER
);
--VERI GIRISI---
INSERT INTO student VALUES('1001','MEHMET ALA',25);
INSERT INTO student VALUES('1002','AYSE',12);

--tablodan veri sorgulama----
SELECT * FROM student;

--tablo silme---
DROP TABLE student;
--PARCALI VERI GIRISI--
INSERT INTO student(id,name)VALUES('1003','FATMA');*//*==================== CONSTRAINS - KISITLAMALAR =======================

NOT NULL - Bir sutunun NULL icermemesini garanti eder.

UNIQUE - Bir sutundaki tum degerlerin BENSERSÝZ olmasini garanti eder. Null
         kabul eder, hatta birden fazla null deger girilebilir.

PRIMARY KEY - Bir sutunun NULL icermemesini ve sutundaki verilerin BENZERSÝZ 
              olmasini garanti eder. (NOT NULL ve UNIQUE birlesimi gibi)
              
FOREIGN KEY - Baska bir tablodaki Primary Key' i referans gostermek icin
              kullanilir. Boylelikle arasinda iliski kurulmus olur.
              
CHECK - Bir sutundaki tum verilerin belirlenen ozel bir sarti saglamasini
        garanti eder. Soldan tablo silerken kapali olmasi lazim
        */
      /*  -----SELECT- WHERE-------
CREATE TABLE ogrenciler
    (
        id NUMBER(9),
        isim VARCHAR2(50),
        adres VARCHAR2(100),
        sinav_notu NUMBER(3)
    );
    INSERT INTO ogrenciler VALUES(123, 'Ali Can', 'Ankara',75);
    INSERT INTO ogrenciler VALUES(124, 'Merve Gul', 'Ankara',85);
    INSERT INTO ogrenciler VALUES(125, 'Kemal Yasa', 'Istanbul',85);
    SELECT*FROM ogrenciler;
       /* ============================================================================
   Verileri SELECT komutu ile veritabanýndan çekerken filtreleme yapmak için
   Syntax
   --------
    SELECT ile birlikte WHERE komutu kullanýlabilir.
    SELECT sutün1, sutün2*/
    
    /* FROM  tablo_adý WHERE koþul;
==============================================================================*/
   /* --Ornek 1 : Sinav notu 80 den buyuk olan ogrencilerin tum bilgilerini listele...
    SELECT*FROM ogrenciler
    WHERE sinav_notu>80;*/
    
   /* -SELECT-- BETWEEN--
     --1.yontem:
    SELECT * FROM personel
     WHERE id BETWEEN '10002' AND '10005';---between de ilk ve son degerdahil
    
  -- 2/YONTEM--
     SELECT * FROM personel
    WHERE ID>='10002' AND ID>='10005';*/
    
    ---NOT between---
     --ornek6: id si 10002-10004 arasýnda OLMAYAN personelin maasýný  listele
 -- SELECT id,maas from personel
--  WHERE id NOT between '10002' AND '10004';
     /* ======================= SELECT - IN ======================================
    IN birden fazla mantýksal ifade ile tanýmlayabileceðimiz durumlarý 
    tek komutla yazabilme imkâný verir*/

  /*  SYNTAX:
    -------
    SELECT sutun1,sutun2, ...
    FROM tablo_adý
    WHERE sutun_adý IN (deger1, deger2, ...);*/
/* ========================================================================== */
    SELECT * FROM personel
    WHERE maas IN (4000,5000,7000);*/
    
    ======================= SELECT - LIKE ======================================
   /* NOT:LIKE anahtar kelimesi, sorgulama yaparken belirli patternleri
    kullanabilmemize olanak saðlar.su gibi istiyorun a ile baslayan gibi
    SYNTAX:
    -------
    SELECT sutün1, sutün2,…
    FROM  tablo_adý WHERE sütun LIKE pattern
    PATTERN ÝÇÝN
    -------------
    %    ---> 0 veya daha fazla karakteri belirtir.
    _    ---> Tek bir karakteri temsil eder.*/
/* ==========================================================================
    --ornek1 ismi a harfi ile baslayanlari listele
 --   SELECT*FROM personel
   --WHERE isim LIKE 'A%';
    
    --UPDATE - SET----
-- SYNTAX
    ----------
    -- UPDATE tablo_adý
    -- SET sutun1 = yeni_deger1, sutun2 = yeni_deger2,...  
    -- WHERE koþul;
    
   --ornek1: vergi_no su 101 olan tedarikcinin firma ismini 'LG' olarak guncelleyin
   
  /* UPDATE tedarikciler1
   SET firma_ismi='LG'
   WHERE vergi_no=101;
   SELECT * FROM tedarikciler1;*/
   
   --  ORNEK1: PERSONEL SAYISI 15.000’den COK OLAN SÝRKETLERÝN ÝSÝMLERÝNÝ (alt sorgu þirketler)ve bu 
 -- sirkette calisan personelin isimlerini ve maaþlarýný (asýl sorgu personel) listeleyin
 --asýl sorgu=>SELECT isim,maas,sirket FROM personel WHERE sirket=istenen
--alt sorgu=>istenen=IN (SELECT sirket_adi FROM sirketler  WHERE personel_sayisi>15000));
  /*  SELECT isim, maas, sirket FROM personel
    
    where sirket IN(SELECT sirket_adi FROM sirketler
    
                    WHERE personel_sayisi>15000);
                    
  -- ORNEK2: sirket_id’si 101’den büyük olan sirket calisanlarinin isim, maas ve 
 -- sehirlerini listeleyiniz. 
 SELECT isim, maas, sehir FROM personel
 WHERE sirket IN(SELECT sirket_adi FROM sirketler
                    WHERE sirket_id>101);*/
   
   /* ===================== AGGREGATE METOT KULLANIMI ===========================

    Aggregate Metotlarý(SUM,COUNT, MIN,MAX, AVG) Subquery içinde kullanýlabilir.
    Ancak, Sorgu tek bir deðer döndürüyor olmalýdýr.


-- *** SELECT den sonra SUBQUERY yazarsak sorgu sonucunun sadece 1 deger getireceginden emin olmaliyiz--SELECT id,isim,maas
                                                                                                        --FROM personel
                                                                                                      --WHERE sirket='Honda';
-- bir tablodan tek deger getirebilmek icin ortalama AVG , toplam SUM, adet COUNT, MIN, MAX  gibi
-- fonksiyonlar kullanilir ve bu fonksiyonlara AGGREGATE FONKSIYONLAR denir
==============================================================================*/   
 
 -- ORNEK4: Her þirketin ismini, personel sayýsýný ve o þirkete ait personelin
--  toplam maaþýný listeleyen bir Sorgu yazýnýz.
                   
   /*  SELECT sirket_adi, personel_sayisi, (SELECT SUM(maas) from personel
                                             WHERE sirketler.sirket_adi=personel.sirket) AS toplam_maas                
                    
            FROM sirketler;   */
            
 --AS takýsýyla istediðimiz sütuna istediðimiz adi verebiliriz        
            
    /*===================== IS NULL, IS NOT NULL, COALESCE(kulesk=birleþmek) ========================
    IS NULL, ve IS NOT NULL BOOLEAN operatörleridir. Bir ifadenin NULL olup
    olmadýðýný kontrol ederler.
    COALESCE (birleþmek) ise bir fonksiyondur ve içerisindeki parameterelerden NULL olmayan
    ilk ifadeyi döndürür. Eðer aldýðý tüm ifadeler NULL ise NULL döndürürür.
   *** select COALESCE (sütun1,sütun2,...) from tabloAdý;
    
    Birden fazla null koþuluna göre deðer atamak istiyorsak COALESCE deyimini kullanabiliriz.
    COALESCE aslýnda case mantýðýnda çalýþýr ve birden fazla kolon arasýnda kontrol saðlayabilirsiniz.
    Bir koþul gerçekleþmez ise diðerine bakar, oda gerçekleþmez ise bir sonraki.
    Deyim bitene kadar
   -- CASE  
   WHEN (expression1 IS NOT NULL) THEN expression1  
   WHEN (expression2 IS NOT NULL) THEN expression2  
   ...  
   ELSE expressionN  
   END  --gibi*/   
   
/*====================== FETCH NEXT, OFFSET (12C VE ÜSTÜ oracle larda çalýþýr, daha altsanýz çalýþmaz) ======================
   FETCH cümleciði ile listelenecek kayýtlarý sýnýrlandýrabiliriz. Ýstersek
   satýr sayýsýna göre istersek de toplam satýr sayýsýnýn belli bir yüzdesine
   göre sýnýrlandýrma koymak mümkündür. (þu kadar satýrý getir)
   Syntax
   ---------
   FETCH NEXT satir_sayisi ROWS ONLY;
   FETCH NEXT satir_yuzdesi PERCENT ROWS ONLY;
   OFFSET Cümleciði ile de listenecek olan satýrlardan sýrasýyla istediðimiz
   kadarýný atlayabiliriz.
   Syntax
   ----------
   OFFSET satýr_sayisi ROWS;*/   
   
   /*============================ GROUP BY =====================================
    GROUP BY cümleciði bir SELECT ifadesinde satýrlarý, sutunlarýn deðerlerine
    göre özet olarak gruplamak için kullanýlýr.
    GROUP BY cümleceði her grup baþýna bir satýr döndürür.
    GROUP BY genelde, AVG(),COUNT(),MAX(),MIN() ve SUM() gibi aggregate
    fonksiyonlarý ile birlikte kullanýlýr.*/
   
    /* ******* KOD SIRALAMASI AÞAÐIDAKÝ GÝBÝ OLMALI********
  =>SELECT FROM
  =>WHERE  1)gruplamadan bazý þartlara göre bazýlarýný ele
  =>GROUP BY 2)özelliklerine göre grupla
  =>HAVÝNG (BÝRAZDAN ÖÐRENÝCEZ)3) grup özelliklerine göre þartla ele. ya where ya having yani
  =>ORDER BY  4) bu gruplarý istenilen özelliðe göre sýrala
  *//*============================= DISTINCT =====================================
    DISTINCT cümleciði bir SORGU ifadesinde benzer olan satýrlarý flitrelemek
    için kullanýlýr. Dolayýsýyla seçilen sutun yada sutunlar için benzersiz veri
    içeren satýrlar oluþturmaya yarar.
    SYNTAX
    -------
    SELECT DISTINCT sutun_adi1, sutun_adi2, satin_adi3
    FROM  tablo_adý;
  */
 /* ORNEK1: satýlan farklý meyve türlerinin sayýsýný listeyen sorguyu yazýnýz.
  (kaç farklý meyve türü var, elma armut üzüm=3)*/

 --select count (Distinct urun_adi) urun_cesit_sayisi from manav;

    /*======================= SELECT - LIKE ======================================
   /* NOT:LIKE anahtar kelimesi, sorgulama yaparken belirli patternleri
    kullanabilmemize olanak saðlar.su gibi istiyorun a ile baslayan gibi
    SYNTAX:
    -------
    SELECT sutün1, sutün2,…
    FROM  tablo_adý WHERE sütun LIKE pattern
    PATTERN ÝÇÝN
    -------------
    %    ---> 0 veya daha fazla karakteri belirtir.
    _    ---> Tek bir karakteri temsil eder.*/
/* ==========================================================================*/
    --ornek9 ismi a harfi ile baslayanlari listele
   -- SELECT*FROM personel
  --  WHERE isim LIKE 'A%';
   
   /* ======================= SELECT - REGEXP_LIKE ================================
    Daha karmaþýk pattern ile sorgulama iþlemi için REGEXP_LIKE kullanýlabilir.  

    Syntax:
    --------
    REGEXP_LIKE(sutun_adý, ‘pattern[] ‘, ‘c’ ] ) 
             -- 'c' => case-sentisitive demektir ve default case-sensitive aktiftir.
     -- 'i' => incase-sentisitive demektir.*/
   
   =========================== DELETE ===================================  

    -- DELETE FROM tablo_adý;  Tablonun tüm içerðini siler.
    -- Bu komut bir DML komutudur. Dolayýsýyla devamýnda WHERE gibi cümlecikler
    -- kullanýlabilir.
    
    
    -- DELETE FROM tablo_adý
    -- WHERE sutun_adi = veri;
   
   /* =============================================================================
         Seçerek silmek için WHERE Anahtar kelimesi kullanýlabilir. 
===============================================================================*/     

/* -----------------------------------------------------------------------------
  ORNEK1: id'si 124 olan ogrenciyi siliniz.
 -----------------------------------------------------------------------------*/ 
  
    --  DELETE FROM ogrenciler
    --  WHERE id = 124;
   
   -*************************************************    
    
      -- tablodaki kayitlari silmek ile tabloyu silmek farkli islemlerdir
-- silme komutlari da iki basamaklidir, biz genelde geri getirilebilecek sekilde sileriz 
-- ancak bazen guvenlik gibi sebeplerle geri getirilmeyecek sekilde silinmesi istenebilir   

/* ======================== DELETE - TRUCATE - DROP ============================   
  
  1-) TRUNCATE komutu DELETE komutu gibi bir tablodaki verilerin tamamýný siler.
    Ancak, seçmeli silme yapamaz. Çünkü Truncate komutu DML deðil DDL komutudur.*/ 
         TRUNCATE TABLE ogrenciler;  --doðru yazým
       
    
   /* 2-) DELETE komutu beraberinde WHERE cümleciði kullanýlabilir. TRUNCATE ile 
    kullanýlmaz.
        TRUNCATE TABLE ogrenciler.....yanlýþ yazým
        WHERE veli_isim='Hasan';
-- TRUNCATE komutu tablo yapýsýný deðiþtirmeden, 
-- tablo içinde yer alan tüm verileri tek komutla silmenizi saðlar.
        
    3-) Delete komutu ile silinen veriler ROLLBACK Komutu ile kolaylýkla geri 
    alýnabilir.
    
    4-) Truncate ile silinen veriler geri alýnmasý daha zordur. Ancak
    Transaction yöntemi ile geri alýnmasý mümkün olabilir.
    
    5-) DROP komutu da bir DDL komutudur. Ancak DROP veriler ile tabloyu da 
    siler. Silinen tablo Veritabanýnýn geri dönüþüm kutusuna gider. Silinen 
    tablo aþaðýdaki komut ile geri alýnabilir. Veya SQL GUI'den geri alýnabilir. 
        
     FLASHBACK TABLE tablo_adý TO BEFORE DROP;  -> tabloyu geri alýr.
     
     PURGE TABLE tablo_adý;        -> Geri dönüþümdeki tabloyu siler.
            
     DROP TABLE tablo_adý PURGE;  -> Tabloyu tamamen siler

connections da table ý sað týkla =>table=>drop, purge iþaretle, çöp kutusuna
atýlmaksýzýn direk siler.
connections recyle bin sað týkla, purge=>tabloyu tamamen siler. flashback=>
tabloyu geri getirir
==============================================================================*/ 
    --INSERT veri giriþinden sonra SAVEPOÝNT ABC; ile verileri buraya sakla
    --(yanlýþlýk yapma olasýlýðýna karþýn önlem gibi, AYNI ÝSÝMDE BAÞKA TABLO VARSA)
    --sonra istediðini sil (ister tümü ister bir kýsmý)
    --sonra savepoint yaptýðýn yerden alttaki gibi rollback ile verileri geri getir
    drop table ogrenciler;
    DELETE FROM ogrenciler;  -- Tüm verileri sil.
    ROLLBACK TO ABC;         -- Silinen Verileri geri getir.
    SELECT
        * FROM ogrencýler;
        
    DROP TABLE ogrenciler;   -- Tabloyu siler ve Veritabanýnýn Çöp kutusuna 
                             -- gönderir. (DDL komutudur.)
    
    
    -- Çöp kutusundaki tabloyu geri getirir.
    FLASHBACK TABLE ogrenciler TO BEFORE DROP; 
         
    -- Tabloyu tamamen siler (Çöp kutusuna atmaz.)
    DROP TABLE ogrenciler PURGE;  
    -- PURGE sadece DROP ile silinmis tablolar icin kullanilir
    -- DROP kullanmadan PURGE komutu kullanmak isterseniz 
    -- ORA-38302: invalid PURGE option hatasi alirsiniz
    -- Tüm veriler hassas bir þekilde siler.rollback ile geri alýnamaz
    
    -- PURGE yapmak icin 2 yontem kullanabiliriz
--1 tek satirda DROP ve PURGE beraber kullanabiliriz
DROP TABLE ogrenciler7 PURGE; 

-- bu komut ile sildigimiz tabloyu geri getirmek icin FLASHBACK komutunu kullansak
-- ORA-38305: object not in RECYCLE BIN hatasini alirsiniz

-- 2 daha once DROP ile silinmis bir tablo varsa sadece PURGE kullanabiliriz
--Tabloyu yeniden olusturalim

DROP TABLE ogrenciler7;
-- bu asamada istersek FLASHBACK ile tablomuzu geri getirebiliriz
PURGE TABLE ogrenciler7;
-- bu asamada istesem de tabloyu geri getiremem
    
 
 
/* =============================================================================
    Tablolar arasýnda iliþki var ise veriler nasýl silinebilir?
============================================================================= */ 
    
         
/*============================== ON DELETE CASCADE =============================

  Her defasýnda önce child tablodaki verileri silmek yerine ON DELETE CASCADE
  silme özelliðini aktif hale getirebiliriz.
  
  Bunun için FK olan satýrýn en sonuna ON DELETE CASCADE komutunu yazmak yeterli
  
==============================================================================*/
   --  ORNEK21: Ýçerisinde 'hi' bulunan kelimeleri listeleyeniz
   
 --  select * from kelimeler where kelime LIKE '%hi%';
-- select * from kelimeler
 --where REGEXP_LIKE (kelime, 'hi');
   
--ORNEK22: Ýçerisinde 'ot' veya 'at' bulunan kelimeleri büyük küçük harfe duyarsýz listele
/*select * from kelimeler
WHERE REGEXP_LIKE (kelime,'at|ot','i'); -- veya iþlemi için | kullanýlýr
   CREATE TABLE notlar 
    ( 
        talebe_id char(3), --FK
        ders_adi varchar2(30), 
        yazili_notu number (3), 
        CONSTRAINT notlar_fk FOREIGN KEY (talebe_id) 
        REFERENCES talebeler(id) ON DELETE CASCADE --on delete cascade sayesinde
       --parent taki silinen bir kayýt ile iliþkili olan tüm child kayýtlarýný
       --siler.  DELETE FROM talebeleR WHERE id = 124; yaparsak child daki 124 lerde silinir.
       --mesela bir hastane silindi o hastanedeki bütün kayýtlar silinmeli, oda böyle olur.
       --cascade yoksa önce child temizlenir sonra parent */
       
       
       
       
       
       
       